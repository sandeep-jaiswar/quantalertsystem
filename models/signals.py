"""
Trading signal models for the Quant Alerts System.

Immutable dataclasses representing trading signals and confidence levels
generated by quantitative strategies.
"""

from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional, Dict, Any


class SignalType(Enum):
    """Trading signal types."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class ConfidenceLevel(Enum):
    """Signal confidence levels."""
    LOW = "LOW"       # < 60%
    MEDIUM = "MEDIUM" # 60-80%
    HIGH = "HIGH"     # > 80%
    
    @classmethod
    def from_score(cls, score: float) -> 'ConfidenceLevel':
        """Convert numeric confidence score to enum."""
        if score >= 0.8:
            return cls.HIGH
        elif score >= 0.6:
            return cls.MEDIUM
        else:
            return cls.LOW


@dataclass(frozen=True)
class TradingSignal:
    """
    A trading signal generated by a quantitative strategy.
    
    Immutable representation of a trading recommendation with all necessary
    metadata for decision making and audit trails.
    """
    symbol: str
    signal_type: SignalType
    confidence: float
    confidence_level: ConfidenceLevel
    strategy_name: str
    timestamp: datetime
    price: Decimal
    indicators: Dict[str, float]
    metadata: Optional[Dict[str, Any]] = None
    
    def __post_init__(self) -> None:
        """Validate signal data."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0 and 1: {self.confidence}")
        
        if self.confidence_level != ConfidenceLevel.from_score(self.confidence):
            raise ValueError(
                f"Confidence level {self.confidence_level} doesn't match "
                f"confidence score {self.confidence}"
            )
        
        if self.price <= 0:
            raise ValueError(f"Price must be positive: {self.price}")
    
    @property
    def is_actionable(self) -> bool:
        """Check if signal has sufficient confidence to be actionable."""
        return self.confidence >= 0.6 and self.signal_type != SignalType.HOLD
    
    @property
    def is_consensus_worthy(self) -> bool:
        """Check if signal is worthy of consensus consideration."""
        return self.confidence >= 0.5
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for serialization."""
        return {
            'symbol': self.symbol,
            'signal_type': self.signal_type.value,
            'confidence': self.confidence,
            'confidence_level': self.confidence_level.value,
            'strategy_name': self.strategy_name,
            'timestamp': self.timestamp.isoformat(),
            'price': float(self.price),
            'indicators': self.indicators,
            'metadata': self.metadata or {}
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TradingSignal':
        """Create signal from dictionary."""
        return cls(
            symbol=data['symbol'],
            signal_type=SignalType(data['signal_type']),
            confidence=data['confidence'],
            confidence_level=ConfidenceLevel(data['confidence_level']),
            strategy_name=data['strategy_name'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            price=Decimal(str(data['price'])),
            indicators=data['indicators'],
            metadata=data.get('metadata')
        )